using System;


using System.Collections;
using System.Collections.Generic;
using System.Linq;

using System.Reflection;
using SObject = System.Object;

using D = System.Diagnostics.Debug;
using MG = MainGrammar.MainGrammar;
using MGRX = MainGrammar.MainGrammarRX;
using NLSPlain;

using ParserComb;

//#if !mock_NamedNode_Types
using SuggestionTree;
using SGA = SuggestionTree.SuggTAdapter;
//#endif




using UnityEngine;




namespace TranslateAndEval {

 

        public class TestSG_TU : TranslationUnit { 
            public override VBoxTU[] VBoxTUs => throw new NotImplementedException();

            public override IEnumerable<OPCode> emit ()                   => throw new NotImplementedException();
            public override preCH_deltaScope    scope(preCH_deltaScope c) => c ; // no decls or refs possible 

            public preCH pre_CH_out ; 
            TypeFilterVBX_TU typefilter = null;


            public TestSG_TU ( MG.SG_EdgeNode edgeNode , preCH preCH_in ) {
                if ( edgeNode.typefilter != null ) {
                    typefilter = new TypeFilterVBX_TU ( preCH_in ,  edgeNode.typefilter  );
                    pre_CH_out = typefilter.preCH_out;
                } else {
                    pre_CH_out = new deferred_adapter_preCH ( ()=> preCH_in.CH );
                }
                // plug in delegate in both cases
            }

        }

        /*
            assuming the scoping process never needs to access VBoxTUs ... 
        */
        public abstract class TU_RX : TranslationUnit
        {
            // again, this is a hack, reverse inheritance arrow later 
            public override VBoxTU[]            VBoxTUs => throw new NotImplementedException();
            public override IEnumerable<OPCode> emit()  => throw new NotImplementedException();
        }

     

        public class FanElemRX_TU : TU_RX
        {
            public TranslationUnit [] subTUs;
            public preCH preCH_out;
            public FanElemRX_TU ( MG.FanElemNode fanElemNode , preCH preCH_in  ) { 
                var _subTUs = new List<TranslationUnit>();
                var loop_preCH = preCH_in;
                foreach ( NamedNode nn in fanElemNode.children ) { 
                    if ( nn is MG.RG_EdgeNode ) { // and thus implicitly generated by RG_Edge_RX, atm it reuses the normal RG_EdgeNode
                        var rg_edgeTU = new RG_EdgeTU_RX( (MG.RG_EdgeNode) nn , loop_preCH ) ;
                        _subTUs.Add(  rg_edgeTU);
                        loop_preCH = rg_edgeTU.preCH_out ;
                    } else throw new NotImplementedException();
                }
                preCH_out = loop_preCH;
                subTUs = _subTUs.ToArray();
            }
            public override preCH_deltaScope scope(preCH_deltaScope c)
            {
                foreach( var sTU in subTUs ) c = sTU.scope(c );
                return c;
            }
        }

        public class RG_EdgeTU_RX : TU_RX
        {
            public readonly preCH preCH_out;
            public readonly Assign_VBXTU assignVTNode = null ;

            public RG_EdgeTU_RX ( MG.RG_EdgeNode rg_EdgeNode , preCH preCH_in ) {
                var memANodeRX = (MGRX.MemANodeRX)rg_EdgeNode.memAVT.children[0];  // todo proper field in MemAVTNode - hard cast doubles as Assert
                memANodeRX.ACMembTypingCallback = () => preCH_in.PayT;
                // for now, and for lazyness: no extra TU_RX for MemARX 
                var memA_preCH_out = new deferred_preCH ( 
                    ()=> { 
                        return new TTuple { 
                            isMulti = false , // todo 
                            PayT    = SGA.MembType_Exact( preCH_in.PayT , memANodeRX.name )
                            };
                        }, 
                    dataSrc: null // not used in RX-case 
                    );

                // todo Assign creates a new Column ( thus distinct preCH ) in the properly translated version 
                // the proper preCH out is that of AssignVT - but since types are identical, and that's all we care for here : this could simply be dropped, but i need the assignVTNode for scoping 

                if ( rg_EdgeNode.assignVT == null ) {
                    preCH_out = memA_preCH_out;    
                } else { 
                    assignVTNode = new Assign_VBXTU(preCH_in , rg_EdgeNode.assignVT );
                    preCH_out = assignVTNode.preCH_out;
                }

            }
            public override preCH_deltaScope scope(preCH_deltaScope c)
            {
                // piggyback the scoping on nonRX variant? 
                if ( assignVTNode != null ) return assignVTNode.scope(c);
                return c;
            }
        }

    public class MemA_VBX_TU_RX : MemA_VBXTU { 
        public MemA_VBX_TU_RX ( preCH preCH_in , MGRX.MemANodeRX memA_node_rx ) : base ( preCH_in , memA_node_rx ) {
            memA_node_rx.ACMembTypingCallback = () => 
                preCH_in.PayT;
        }
    }
    
    public class PrimitiveStepTU_RX : PrimitveStepTU {
        public PrimitiveStepTU_RX ( preCH preCH_in , MGRX.PrimitiveStepNode prim_step_node )  {
            // pretty fucky - copy and paste job from the nonRX variant - needed though to plug in the RX constructors for child TUs
            this.primtv_step_node = prim_step_node;       //
            var primaryNN = primtv_step_node.children[0];
            if        ( primaryNN is MG.SG_EdgeNode ) {

                primaryTU           = new SG_EdgeTU( preCH_in , (MG.SG_EdgeNode) primaryNN ) ;
                primary_preCH_out   = ((SG_EdgeTU) primaryTU).preCH_out;

            } else if ( primaryNN is MG.MemANode ) {
                var MemTU = new MemA_VBX_TU_RX(preCH_in , (MGRX.MemANodeRX) primaryNN) ;          //  type - patch I
                primaryTU = MemTU;
                primary_preCH_out = MemTU.preCH_out;
            
            } else if ( primaryNN is MG.FilterNode ) {
                var filterTU = new FilterTU( preCH_in , (MG.FilterNode) primaryNN );
                primaryTU = filterTU;
                primary_preCH_out = filterTU.preCH_out;
            } else if ( primaryNN is MG.FanNode ) {
                var fanTU = new FanTU( preCH_in , (MG.FanNode) primaryNN) ;
                primaryTU = fanTU;
                primary_preCH_out = fanTU.pRHS;
            } else throw new Exception();  // grammar changed or parser bug 

            preCH current_preCH_out = primary_preCH_out;
            foreach( var asgn_node in primtv_step_node.assigns) {
                var asgn_TU = new Assign_VBXTU( current_preCH_out , asgn_node );
                assigns.Add( asgn_TU);
                current_preCH_out = asgn_TU.preCH_out;
            }
            preCH_out = current_preCH_out; 
        }
    }


    public class FunCallTU_RX : FunCallTU {
        /*
            this thing has potentially thwo ACable nodes under its belly 
            since the search goes leaf-up and TypeNameNode is itself acable - the only possible hit is for the function name 
        */
        public preCH dummyErrorPreCH = new deferred_preCH( () => throw new Exception("can't determine return type of empty function name " ) , null ) ;

        public override preCH preCH_out => call != null ? call.preCH_out : dummyErrorPreCH ;

        public FunCallTU_RX( preCH preCH_in , MGRX.FunCallNodeRX funCallNodeRX )  {
            // this needs to mimic the base constructor almost exactly , 
            // luckily it's not complicated at all 
            this.funCallNode = funCallNodeRX; 

            frameTU         = new FrameTU( preCH_in , funCallNode.frameNode ) ;
            tupleExtract    = new TupleExtractVBXTU( frameTU.preCH_out  );
            if ( funCallNodeRX.haveMethodName ) { 
                call            = new CallVBXTU( (TypedSingleCH<arg_tuple>) tupleExtract.CH_out , funCallNode  ) ;
            } else { 
                call = null ; // just to make it explicit ( preCH_out switch ) 
            }

            
            if ( funCallNodeRX.haveMethodName ) {  // and by extension FunNameNodeRX 
                if ( funCallNode.isStatic ) 
                    funCallNodeRX.funcNameNodeRX.AC_FuncHostingType_Callback = staticFun_dele ;
                else 
                    funCallNodeRX.funcNameNodeRX.AC_FuncHostingType_Callback = instFun_dele ; 
            }
            
        } 
        /*
            possibilities : 
                - function is static 
                    -> read out TypeNameNode
                - function is member , first data column can be typed without roundabout 
                    -> collapse dataCHs[0].preCH_out and fetch type 
                - function is member , first data column is a @"literal" and needs the roundabout 
                    - we are fucked
                    - don't even try AC - too much of an headache 
        */

        public Type staticFun_dele() { 
            var TNN = (funCallNode as MGRX.FunCallNodeRX).typeNameNode;
            return SGA.QTN_Exact( TNN.names ) ; 
        }
        public Type instFun_dele() {
            var frameElems = frameTU.frameElemTUs; 

            if ( frameElems.Length == 0 ) throw new Exception( " trying to get hosting type of member func with zero len arguments frame " ) ;
            var typingElem = frameElems[0];

            if ( typingElem.isConst )     throw new Exception( " trying to derive hosting type from literal " ) ; 
            return typingElem.preCH_out.PayT ; 
        }

        
    }


    
    public class ProvStartTU_RX : ProvStartTU
    {
        public ProvStartTU_RX ( MGRX.ProvStartNode start_node ) {
            // copy pasta'd from base()

            preCH subseqLHS = null ; 
            if ( start_node.rootIsSG ) {

                root_SG_edge = new Root_SG_EdgeTU( start_node.startSG );
                rootIsSG = true ;
                subseqLHS = root_SG_edge.preCH_out;

            } else { 

                var dummy_root_CH = new TypedSingleCH<int>();
                dummy_Suigen = new OP_SuiGen<int>( dummy_root_CH , ( _ ) => new [] { 1} ) ; 
                root_FunCall = new FunCallTU_RX  ( new adapter_preCH( dummy_root_CH ) , (MGRX.FunCallNodeRX)start_node.startFuncall ) ;
                rootIsSG = false ; 
                subseqLHS = root_FunCall.preCH_out;

            }

            var   L             = new List<TranslationUnit>();
            preCH current_preCH = subseqLHS ; 

            foreach ( var subseq_step in start_node.subsequentSteps ) {
                if ( subseq_step is MGRX.PrimitiveStepNode) {  
                    var TU = new PrimitiveStepTU_RX( current_preCH, (MGRX.PrimitiveStepNode) subseq_step  );
                    L.Add( TU  );
                    current_preCH = TU.preCH_out;
                } else if ( subseq_step is MGRX.FunCallNodeRX)  {
                    var TU = new FunCallTU_RX( current_preCH , (MGRX.FunCallNodeRX) subseq_step);
                    L.Add( TU );
                    current_preCH = TU.preCH_out;

                } else throw new NotImplementedException();
                
            }
            subsequent_Steps = L.ToArray();
        }

        public override preCH_deltaScope scope(preCH_deltaScope c)
        {
            // root_SG_edge doesnt do scopemafing
            foreach( var subseqStep in subsequent_Steps ) c = subseqStep.scope( c ) ;
            return c ;
        }

    }

    

}